import { Request, Response, NextFunction } from "express";
import Booking from "../infrastructure/entities/Booking";
import Hotel from "../infrastructure/entities/Hotel";
import ValidationError from "../domain/errors/validation-error";
import NotFoundError from "../domain/errors/not-found-error";
import { getAuth } from "@clerk/express";
import { stripe } from "./utils/stripe";
import { handleStripeError } from "./utils/payment-errors";

// Helper function to calculate total price
const calculateTotalPrice = (checkIn: Date, checkOut: Date, basePrice: number): number => {
  const nights = Math.ceil((checkOut.getTime() - checkIn.getTime()) / (1000 * 60 * 60 * 24));
  return nights * basePrice;
};

// Helper function to check room availability
const checkRoomAvailability = async (hotelId: string, roomNumber: number, checkIn: Date, checkOut: Date, excludeBookingId?: string): Promise<boolean> => {
  const query: any = {
    hotelId,
    roomNumber,
    status: { $in: ["CONFIRMED", "PENDING"] },
    $or: [
      {
        checkIn: { $lt: checkOut },
        checkOut: { $gt: checkIn }
      }
    ]
  };

  // Exclude current booking when updating
  if (excludeBookingId) {
    query._id = { $ne: excludeBookingId };
  }

  const conflictingBookings = await Booking.find(query);
  
  return conflictingBookings.length === 0;
};

// Create a new booking
export const createBooking = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { checkIn, checkOut, hotelId, guestCount = 1, specialRequests } = req.body;
    
    // Validate required fields (roomNumber is auto-generated, so not required)
    if (!checkIn || !checkOut || !hotelId) {
      throw new ValidationError("checkIn, checkOut, and hotelId are required");
    }

    // Validate dates
    const checkInDate = new Date(checkIn);
    const checkOutDate = new Date(checkOut);
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    if (checkInDate < today) {
      throw new ValidationError("Check-in date cannot be in the past");
    }

    if (checkOutDate <= checkInDate) {
      throw new ValidationError("Check-out date must be after check-in date");
    }

    // Validate guest count
    if (guestCount < 1 || guestCount > 10) {
      throw new ValidationError("Guest count must be between 1 and 10");
    }

    // Find hotel and validate it exists
    const hotel = await Hotel.findById(hotelId);
    if (!hotel) throw new NotFoundError("Hotel not found");
    
    console.log("Found hotel:", { name: hotel.name, price: hotel.price });

    const { userId } = getAuth(req);
    if (!userId) {
      throw new ValidationError("User authentication required");
    }
    console.log("User ID:", userId);

    // Calculate total price (assuming hotel has a basePrice field)
    const basePrice = hotel.price || 100; // Default price if not set
    const totalPrice = calculateTotalPrice(checkInDate, checkOutDate, basePrice);
    console.log("Calculated total price:", totalPrice);

    // Room number will be auto-generated by the pre-save hook
    const bookingData = {
      userId,
      hotelId,
      checkIn: checkInDate,
      checkOut: checkOutDate,
      // roomNumber is auto-generated, so we don't set it here
      guestCount,
      specialRequests,
      totalPrice,
      paymentStatus: "PENDING",
      status: "PENDING",
    };
    
    console.log("Creating booking with data:", bookingData);

    const booking = await Booking.create(bookingData);

    // Create Stripe checkout session
    if (!process.env.STRIPE_SECRET_KEY) {
      throw new Error("STRIPE_SECRET_KEY is not configured");
    }

    // Calculate number of nights
    const nights = Math.ceil((checkOutDate.getTime() - checkInDate.getTime()) / (1000 * 60 * 60 * 24));

    // Prepare line items - use Stripe price ID if available, otherwise create price_data
    const lineItems = [];
    
    if (hotel.stripePriceId) {
      // Use existing Stripe price ID (price is per night)
      lineItems.push({
        price: hotel.stripePriceId,
        quantity: nights,
      });
    } else {
      // Fallback: create price_data on the fly (for hotels without Stripe price)
      lineItems.push({
        price_data: {
          currency: "usd",
          product_data: {
            name: `${hotel.name} - Booking`,
            description: `Check-in: ${checkInDate.toLocaleDateString()} - Check-out: ${checkOutDate.toLocaleDateString()}`,
          },
          unit_amount: Math.round(totalPrice * 100), // Convert to cents
        },
        quantity: 1,
      });
    }

    let session;
    try {
      session = await stripe.checkout.sessions.create({
        payment_method_types: ["card"],
        line_items: lineItems,
        mode: "payment",
        ui_mode: "embedded", // Use embedded checkout
        return_url: `${process.env.FRONTEND_URL || "http://localhost:5173"}/booking-confirmation?session_id={CHECKOUT_SESSION_ID}`,
        metadata: {
          bookingId: booking._id.toString(),
          userId: userId,
          hotelId: hotelId,
        },
      });
    } catch (stripeError: any) {
      console.error("Stripe checkout session creation failed:", stripeError.message);
      const paymentError = handleStripeError(stripeError);
      throw new ValidationError(`Payment session creation failed: ${paymentError.message}`);
    }

    if (!session.client_secret) {
      throw new Error("Failed to create payment session. Client secret not available.");
    }

    const response = {
      bookingId: booking._id.toString(),
      sessionId: session.id,
      clientSecret: session.client_secret, // Required for embedded checkout
      booking, // Also include full booking object for convenience
    };

    res.status(201).json(response);
  } catch (err) {
    next(err);
  }
};

// Get bookings of the logged-in user
export const getMyBookings = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { userId } = getAuth(req);
    // Sort by most recent first (createdAt descending)
    const bookings = await Booking.find({ userId })
      .populate("hotelId", "name location address image")
      .sort({ createdAt: -1 });

    res.status(200).json(bookings);
  } catch (err) {
    next(err);
  }
};

// Get all bookings (for admin dashboard / public)
export const getAllBookings = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const bookings = await Booking.find({}).populate("hotelId", "name location address");

    res.status(200).json(bookings);
  } catch (err) {
    next(err);
  }
};

// Cancel a booking
export const cancelBooking = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { bookingId } = req.params;
    const { userId } = getAuth(req);

    const booking = await Booking.findOne({ _id: bookingId, userId });
    if (!booking) {
      throw new NotFoundError("Booking not found");
    }

    // Check if booking can be cancelled (not already cancelled or completed)
    if (booking.status === "CANCELLED") {
      throw new ValidationError("Booking is already cancelled");
    }

    if (booking.status === "COMPLETED") {
      throw new ValidationError("Cannot cancel a completed booking");
    }

    // Check if cancellation is within allowed timeframe (e.g., 24 hours before check-in)
    const now = new Date();
    const checkInDate = new Date(booking.checkIn);
    const hoursUntilCheckIn = (checkInDate.getTime() - now.getTime()) / (1000 * 60 * 60);

    if (hoursUntilCheckIn < 24) {
      throw new ValidationError("Cannot cancel booking within 24 hours of check-in");
    }

    booking.status = "CANCELLED";
    booking.paymentStatus = "REFUNDED";
    await booking.save();

    res.status(200).json({ message: "Booking cancelled successfully", booking });
  } catch (err) {
    next(err);
  }
};

// Update a booking
export const updateBooking = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { bookingId } = req.params;
    const { checkIn, checkOut, roomNumber, guestCount, specialRequests } = req.body;
    const { userId } = getAuth(req);

    const booking = await Booking.findOne({ _id: bookingId, userId });
    if (!booking) {
      throw new NotFoundError("Booking not found");
    }

    // Check if booking can be updated
    if (booking.status === "CANCELLED") {
      throw new ValidationError("Cannot update a cancelled booking");
    }

    if (booking.status === "COMPLETED") {
      throw new ValidationError("Cannot update a completed booking");
    }

    // Validate dates if provided
    if (checkIn || checkOut) {
      const checkInDate = checkIn ? new Date(checkIn) : booking.checkIn;
      const checkOutDate = checkOut ? new Date(checkOut) : booking.checkOut;
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      if (checkInDate < today) {
        throw new ValidationError("Check-in date cannot be in the past");
      }

      if (checkOutDate <= checkInDate) {
        throw new ValidationError("Check-out date must be after check-in date");
      }

      // Check room availability for new dates if dates or room changed
      const newRoomNumber = roomNumber || booking.roomNumber;
      const isAvailable = await checkRoomAvailability(
        booking.hotelId.toString(),
        newRoomNumber,
        checkInDate,
        checkOutDate,
        bookingId // Exclude current booking from availability check
      );
      
      if (!isAvailable) {
        throw new ValidationError("Room is not available for the selected dates");
      }
    }

    // Update booking fields
    if (checkIn) booking.checkIn = new Date(checkIn);
    if (checkOut) booking.checkOut = new Date(checkOut);
    if (roomNumber) booking.roomNumber = roomNumber;
    if (guestCount) booking.guestCount = guestCount;
    if (specialRequests !== undefined) booking.specialRequests = specialRequests;

    // Recalculate total price if dates changed
    if (checkIn || checkOut) {
      const hotel = await Hotel.findById(booking.hotelId);
      const basePrice = hotel?.price || 100;
      booking.totalPrice = calculateTotalPrice(booking.checkIn, booking.checkOut, basePrice);
    }

    await booking.save();

    res.status(200).json({ message: "Booking updated successfully", booking });
  } catch (err) {
    next(err);
  }
};

// Get booking by ID
export const getBookingById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { bookingId } = req.params;
    const { userId } = getAuth(req);

    const booking = await Booking.findOne({ _id: bookingId, userId })
      .populate("hotelId", "name location address price");

    if (!booking) {
      throw new NotFoundError("Booking not found");
    }

    res.status(200).json(booking);
  } catch (err) {
    next(err);
  }
};

// Get booking by Stripe session ID
export const getBookingBySessionId = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { sessionId } = req.params;
    
    if (!process.env.STRIPE_SECRET_KEY) {
      throw new Error("STRIPE_SECRET_KEY is not configured");
    }

    // Retrieve the session from Stripe to get bookingId from metadata
    const session = await stripe.checkout.sessions.retrieve(sessionId);
    const bookingId = session.metadata?.bookingId;

    if (!bookingId) {
      throw new NotFoundError("Booking not found for this session");
    }

    // Get the booking
    let booking = await Booking.findById(bookingId)
      .populate("hotelId", "name location address price");

    if (!booking) {
      throw new NotFoundError("Booking not found");
    }

    // If payment was successful but booking status hasn't been updated yet (webhook delay),
    // update it now based on Stripe session payment status
    if (session.payment_status === "paid" && booking.paymentStatus !== "PAID") {
      console.log(`Updating booking ${bookingId} to PAID based on Stripe session payment status`);
      booking = await Booking.findByIdAndUpdate(
        bookingId,
        {
          status: "PAID",
          paymentStatus: "PAID",
        },
        { new: true }
      ).populate("hotelId", "name location address price");
    }

    res.status(200).json(booking);
  } catch (err) {
    next(err);
  }
};

// Confirm booking (admin only)
export const confirmBooking = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { bookingId } = req.params;
    const { emailMessage } = req.body;

    const booking = await Booking.findById(bookingId).populate("hotelId", "name location address price");
    if (!booking) {
      throw new NotFoundError("Booking not found");
    }

    if (booking.status === "CONFIRMED") {
      throw new ValidationError("Booking is already confirmed");
    }

    if (booking.status === "CANCELLED") {
      throw new ValidationError("Cannot confirm a cancelled booking");
    }

    // Update booking status
    booking.status = "CONFIRMED";
    booking.paymentStatus = "PAID"; // Assume payment is confirmed when admin confirms
    await booking.save();

    // TODO: Send email notification here
    // For now, we'll just log the email content
    console.log("Email notification would be sent:", {
      to: booking.userId, // In real app, you'd get user email from user service
      subject: `Booking Confirmed - ${(booking.hotelId as any).name}`,
      message: emailMessage || `Your booking at ${(booking.hotelId as any).name} has been confirmed!`
    });

    res.status(200).json({ 
      message: "Booking confirmed successfully", 
      booking,
      emailSent: true 
    });
  } catch (err) {
    next(err);
  }
};

// Update booking status (admin only)
export const updateBookingStatus = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { bookingId } = req.params;
    const { status } = req.body;

    const validStatuses = ["PENDING", "CONFIRMED", "CANCELLED", "COMPLETED"];
    if (!validStatuses.includes(status)) {
      throw new ValidationError("Invalid status. Must be one of: " + validStatuses.join(", "));
    }

    const booking = await Booking.findById(bookingId);
    if (!booking) {
      throw new NotFoundError("Booking not found");
    }

    booking.status = status;
    
    // Update payment status based on booking status
    if (status === "CANCELLED") {
      booking.paymentStatus = "REFUNDED";
    } else if (status === "CONFIRMED") {
      booking.paymentStatus = "PAID";
    }

    await booking.save();

    res.status(200).json({ 
      message: "Booking status updated successfully", 
      booking 
    });
  } catch (err) {
    next(err);
  }
};
